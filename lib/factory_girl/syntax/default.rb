module FactoryGirl

  module Syntax
    module Default

    end
  end

  class Factory

    # Defines a new factory that can be used by the build strategies (create and
    # build) to build new objects.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   A unique name used to identify this factory.
    # * options: +Hash+
    #
    # Options:
    # * class: +Symbol+, +Class+, or +String+
    #   The class that will be used when generating instances for this factory. If not specified, the class will be guessed from the factory name.
    # * parent: +Symbol+
    #   The parent factory. If specified, the attributes from the parent
    #   factory will be copied to the current one with an ability to override
    #   them.
    # * default_strategy: +Symbol+
    #   The strategy that will be used by the Factory shortcut method.
    #   Defaults to :create.
    #
    # Yields: +Factory+
    # The newly created factory.
    def self.define (name, options = {})
      instance = Factory.new(name, options)
      yield(instance)
      if parent = options.delete(:parent)
        instance.inherit_from(Factory.factory_by_name(parent))
      end    
      self.factories[instance.factory_name] = instance
    end

    # Adds an attribute that should be assigned on generated instances for this
    # factory.
    #
    # This method should be called with either a value or block, but not both. If
    # called with a block, the attribute will be generated "lazily," whenever an
    # instance is generated. Lazy attribute blocks will not be called if that
    # attribute is overriden for a specific instance.
    #
    # When defining lazy attributes, an instance of Factory::Proxy will
    # be yielded, allowing associations to be built using the correct build
    # strategy.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   The name of this attribute. This will be assigned using :"#{name}=" for
    #   generated instances.
    # * value: +Object+
    #   If no block is given, this value will be used for this attribute.
    def add_attribute (name, value = nil, &block)
      if block_given?
        if value
          raise AttributeDefinitionError, "Both value and block given"
        else
          attribute = Attribute::Dynamic.new(name, block)
        end
      else
        attribute = Attribute::Static.new(name, value)
      end

      if attribute_defined?(attribute.name)
        raise AttributeDefinitionError, "Attribute already defined: #{name}"
      end

      @attributes << attribute
    end

    # Calls add_attribute using the missing method name as the name of the
    # attribute, so that:
    #
    #   Factory.define :user do |f|
    #     f.name 'Billy Idol'
    #   end
    #
    # and:
    #
    #   Factory.define :user do |f|
    #     f.add_attribute :name, 'Billy Idol'
    #   end
    #
    # are equivilent. 
    def method_missing (name, *args, &block)
      add_attribute(name, *args, &block)
    end

    # Adds an attribute that builds an association. The associated instance will
    # be built using the same build strategy as the parent instance.
    #
    # Example:
    #   Factory.define :user do |f|
    #     f.name 'Joey'
    #   end
    #
    #   Factory.define :post do |f|
    #     f.association :author, :factory => :user
    #   end
    #
    # Arguments:
    # * name: +Symbol+
    #   The name of this attribute.
    # * options: +Hash+
    #
    # Options:
    # * factory: +Symbol+ or +String+
    #    The name of the factory to use when building the associated instance.
    #    If no name is given, the name of the attribute is assumed to be the
    #    name of the factory. For example, a "user" association will by
    #    default use the "user" factory.
    def association (name, options = {})
      factory_name = options.delete(:factory) || name
      if factory_name_for(factory_name) == self.factory_name
        raise AssociationDefinitionError, "Self-referencing association '#{name}' in factory '#{self.factory_name}'"
      end
      @attributes << Attribute::Association.new(name, factory_name, options)
    end

    # Adds an attribute that will have unique values generated by a sequence with
    # a specified format.
    #
    # The result of:
    #   Factory.define :user do |f|
    #    f.sequence(:email) { |n| "person#{n}@example.com" }
    #   end
    #
    # Is equal to:
    #   Factory.sequence(:email) { |n| "person#{n}@example.com" }
    #
    #   Factory.define :user do |f|
    #    f.email { Factory.next(:email) }
    #   end
    #
    # Except that no globally available sequence will be defined.
    def sequence (name, &block)
      s = Sequence.new(&block)
      add_attribute(name) { s.next }
    end

    # Generates and returns a Hash of attributes from this factory. Attributes
    # can be individually overridden by passing in a Hash of attribute => value
    # pairs.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   The name of the factory that should be used.
    # * overrides: +Hash+
    #   Attributes to overwrite for this set.
    #
    # Returns: +Hash+
    # A set of attributes that can be used to build an instance of the class
    # this factory generates. 
    def self.attributes_for (name, overrides = {})
      factory_by_name(name).run(Proxy::AttributesFor, overrides)
    end

    # Generates and returns an instance from this factory. Attributes can be
    # individually overridden by passing in a Hash of attribute => value pairs.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   The name of the factory that should be used.
    # * overrides: +Hash+
    #   Attributes to overwrite for this instance.
    #
    # Returns: +Object+
    # An instance of the class this factory generates, with generated attributes
    # assigned.
    def self.build (name, overrides = {})
      factory_by_name(name).run(Proxy::Build, overrides)
    end

    # Generates, saves, and returns an instance from this factory. Attributes can
    # be individually overridden by passing in a Hash of attribute => value
    # pairs.
    #
    # Instances are saved using the +save!+ method, so ActiveRecord models will
    # raise ActiveRecord::RecordInvalid exceptions for invalid attribute sets.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   The name of the factory that should be used.
    # * overrides: +Hash+
    #   Attributes to overwrite for this instance.
    #
    # Returns: +Object+
    # A saved instance of the class this factory generates, with generated
    # attributes assigned.
    def self.create (name, overrides = {})
      factory_by_name(name).run(Proxy::Create, overrides)
    end
    
    # Generates and returns an object with all attributes from this factory
    # stubbed out. Attributes can be individually overridden by passing in a Hash
    # of attribute => value pairs.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   The name of the factory that should be used.
    # * overrides: +Hash+
    #   Attributes to overwrite for this instance.
    #
    # Returns: +Object+
    # An object with generated attributes stubbed out.
    def self.stub (name, overrides = {})
      factory_by_name(name).run(Proxy::Stub, overrides)
    end
    
    # Executes the default strategy for the given factory. This is usually create,
    # but it can be overridden for each factory.
    #
    # Arguments:
    # * name: +Symbol+ or +String+
    #   The name of the factory that should be used.
    # * overrides: +Hash+
    #   Attributes to overwrite for this instance.
    #
    # Returns: +Object+
    # The result of the default strategy.
    def self.default_strategy (name, overrides = {})  
      self.send(factory_by_name(name).default_strategy, name, overrides)
    end

    def self.find_definitions #:nodoc:
      definition_file_paths.each do |path|
        require("#{path}.rb") if File.exists?("#{path}.rb")

        if File.directory? path
          Dir[File.join(path, '*.rb')].each do |file|
            require file
          end
        end
      end
    end

  end

end
