module FactoryGirl

  module Syntax
    module Default
      class DefinitionProxy

        attr_reader :attributes

        def initialize
          @attributes = []
        end

        # Adds an attribute that will have unique values generated by a sequence with
        # a specified format.
        #
        # The result of:
        #   Factory.define :user do |f|
        #    f.sequence(:email) { |n| "person#{n}@example.com" }
        #   end
        #
        # Is equal to:
        #   Factory.sequence(:email) { |n| "person#{n}@example.com" }
        #
        #   Factory.define :user do |f|
        #    f.email { Factory.next(:email) }
        #   end
        #
        # Except that no globally available sequence will be defined.
        def sequence(name, &block)
          s = Sequence.new(&block)
          add_attribute(name) { s.next }
        end

        # Adds an attribute that should be assigned on generated instances for this
        # factory.
        #
        # This method should be called with either a value or block, but not both. If
        # called with a block, the attribute will be generated "lazily," whenever an
        # instance is generated. Lazy attribute blocks will not be called if that
        # attribute is overriden for a specific instance.
        #
        # When defining lazy attributes, an instance of Factory::Proxy will
        # be yielded, allowing associations to be built using the correct build
        # strategy.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   The name of this attribute. This will be assigned using :"#{name}=" for
        #   generated instances.
        # * value: +Object+
        #   If no block is given, this value will be used for this attribute.
        def add_attribute(name, value = nil, &block)
          if block_given?
            if value
              raise AttributeDefinitionError, "Both value and block given"
            else
              attribute = Attribute::Dynamic.new(name, block)
            end
          else
            attribute = Attribute::Static.new(name, value)
          end

          @attributes << attribute
        end

        # Calls add_attribute using the missing method name as the name of the
        # attribute, so that:
        #
        #   Factory.define :user do |f|
        #     f.name 'Billy Idol'
        #   end
        #
        # and:
        #
        #   Factory.define :user do |f|
        #     f.add_attribute :name, 'Billy Idol'
        #   end
        #
        # are equivilent.
        def method_missing(name, *args, &block)
          add_attribute(name, *args, &block)
        end

        # Adds an attribute that builds an association. The associated instance will
        # be built using the same build strategy as the parent instance.
        #
        # Example:
        #   Factory.define :user do |f|
        #     f.name 'Joey'
        #   end
        #
        #   Factory.define :post do |f|
        #     f.association :author, :factory => :user
        #   end
        #
        # Arguments:
        # * name: +Symbol+
        #   The name of this attribute.
        # * options: +Hash+
        #
        # Options:
        # * factory: +Symbol+ or +String+
        #    The name of the factory to use when building the associated instance.
        #    If no name is given, the name of the attribute is assumed to be the
        #    name of the factory. For example, a "user" association will by
        #    default use the "user" factory.
        def association(name, options = {})
          factory_name = options.delete(:factory) || name
          # if Factory.factory_name_for
          #   raise AssociationDefinitionError, "Self-referencing association '#{name}' in factory '#{self.factory_name}'"
          # end
          @attributes << Attribute::Association.new(name, factory_name, options)
        end

        def after_build(&block)
          callback(:after_build, &block)
        end

        def after_create(&block)
          callback(:after_create, &block)
        end

        def after_stub(&block)
          callback(:after_stub, &block)
        end

        def callback(name, &block)
          unless [:after_build, :after_create, :after_stub].include?(name.to_sym)
            raise InvalidCallbackNameError, "#{name} is not a valid callback name. Valid callback names are :after_build, :after_create, and :after_stub"
          end
          @attributes << Attribute::Callback.new(name.to_sym, block)
        end
      end

      module Factory

        # Defines a new factory that can be used by the build strategies (create and
        # build) to build new objects.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   A unique name used to identify this factory.
        # * options: +Hash+
        #
        # Options:
        # * class: +Symbol+, +Class+, or +String+
        #   The class that will be used when generating instances for this factory. If not specified, the class will be guessed from the factory name.
        # * parent: +Symbol+
        #   The parent factory. If specified, the attributes from the parent
        #   factory will be copied to the current one with an ability to override
        #   them.
        # * default_strategy: +Symbol+
        #   The strategy that will be used by the Factory shortcut method.
        #   Defaults to :create.
        #
        # Yields: +Factory+
        # The newly created factory.
        def self.define(name_or_class, options = {})
          name = factory_name_for(name_or_class)
          proxy = Syntax::Default::DefinitionProxy.new
          yield(proxy)
          parent_build_class =
            if options[:parent]
              FactoryGirl::Factory.factory_by_name(options[:parent]).build_class
            else
              nil
            end
          build_class = class_for(options[:class] ||
                                  parent_build_class ||
                                  name_or_class)
          instance = FactoryGirl::Factory.new(build_class, proxy.attributes, options)
          instance.ensure_not_associated_with(name)
          if FactoryGirl::Factory.factories[name]
            raise DuplicateDefinitionError, "Factory already defined: #{name}"
          end
          FactoryGirl::Factory.factories[name] = instance
        end

        # TODO: move this into an inflector module
        def self.class_for(class_or_to_s)
          if class_or_to_s.respond_to?(:to_sym)
            Object.const_get(variable_name_to_class_name(class_or_to_s))
          else
            class_or_to_s
          end
        end

        # TODO: move this into an inflector module
        def self.factory_name_for(class_or_to_s)
          if class_or_to_s.respond_to?(:to_sym)
            class_or_to_s.to_sym
          else
            class_name_to_variable_name(class_or_to_s).to_sym
          end
        end

        # Based on ActiveSupport's camelize inflector
        # TODO: move this into an inflector module
        def self.variable_name_to_class_name(name)
          name.to_s.
            gsub(/\/(.?)/) { "::#{$1.upcase}" }.
            gsub(/(?:^|_)(.)/) { $1.upcase }
        end

        # Based on ActiveSupport's underscore inflector
        # TODO: move this into an inflector module
        def self.class_name_to_variable_name(name)
          name.to_s.gsub(/::/, '/').
            gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
            gsub(/([a-z\d])([A-Z])/,'\1_\2').
            tr("-", "_").
            downcase
        end

        # Generates and returns a Hash of attributes from this factory. Attributes
        # can be individually overridden by passing in a Hash of attribute => value
        # pairs.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   The name of the factory that should be used.
        # * overrides: +Hash+
        #   Attributes to overwrite for this set.
        #
        # Returns: +Hash+
        # A set of attributes that can be used to build an instance of the class
        # this factory generates.
        def self.attributes_for(name, overrides = {})
          FactoryGirl::Factory.factory_by_name(name).run(:attributes_for, overrides)
        end

        # Generates and returns an instance from this factory. Attributes can be
        # individually overridden by passing in a Hash of attribute => value pairs.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   The name of the factory that should be used.
        # * overrides: +Hash+
        #   Attributes to overwrite for this instance.
        #
        # Returns: +Object+
        # An instance of the class this factory generates, with generated attributes
        # assigned.
        def self.build(name, overrides = {})
          FactoryGirl::Factory.factory_by_name(name).run(:build, overrides)
        end

        # Generates, saves, and returns an instance from this factory. Attributes can
        # be individually overridden by passing in a Hash of attribute => value
        # pairs.
        #
        # Instances are saved using the +save!+ method, so ActiveRecord models will
        # raise ActiveRecord::RecordInvalid exceptions for invalid attribute sets.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   The name of the factory that should be used.
        # * overrides: +Hash+
        #   Attributes to overwrite for this instance.
        #
        # Returns: +Object+
        # A saved instance of the class this factory generates, with generated
        # attributes assigned.
        def self.create(name, overrides = {})
          FactoryGirl::Factory.factory_by_name(name).run(:create, overrides)
        end

        # Generates and returns an object with all attributes from this factory
        # stubbed out. Attributes can be individually overridden by passing in a Hash
        # of attribute => value pairs.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   The name of the factory that should be used.
        # * overrides: +Hash+
        #   Attributes to overwrite for this instance.
        #
        # Returns: +Object+
        # An object with generated attributes stubbed out.
        def self.stub(name, overrides = {})
          FactoryGirl::Factory.factory_by_name(name).run(:stub, overrides)
        end

        # Executes the default strategy for the given factory. This is usually create,
        # but it can be overridden for each factory.
        #
        # Arguments:
        # * name: +Symbol+ or +String+
        #   The name of the factory that should be used.
        # * overrides: +Hash+
        #   Attributes to overwrite for this instance.
        #
        # Returns: +Object+
        # The result of the default strategy.
        def self.default_strategy(name, overrides = {})
          factory = FactoryGirl::Factory.factory_by_name(name)
          self.send(factory.default_strategy, name, overrides)
        end

        def self.find_definitions #:nodoc:
          FactoryGirl::Factory.definition_file_paths.each do |path|
            require("#{path}.rb") if File.exists?("#{path}.rb")

            if File.directory? path
              Dir[File.join(path, '*.rb')].each do |file|
                require file
              end
            end
          end
        end

        # Defines a new sequence that can be used to generate unique values in a specific format.
        #
        # Arguments:
        #   name: (Symbol)
        #     A unique name for this sequence. This name will be referenced when
        #     calling next to generate new values from this sequence.
        #   block: (Proc)
        #     The code to generate each value in the sequence. This block will be
        #     called with a unique number each time a value in the sequence is to be
        #     generated. The block should return the generated value for the
        #     sequence.
        #
        # Example:
        #
        #   Factory.sequence(:email) {|n| "somebody_#{n}@example.com" }
        def self.sequence (name, &block)
          FactoryGirl::Sequence.sequences[name] = Sequence.new(&block)
        end

        # Generates and returns the next value in a sequence.
        #
        # Arguments:
        #   name: (Symbol)
        #     The name of the sequence that a value should be generated for.
        #
        # Returns:
        #   The next value in the sequence. (Object)
        def self.next (sequence)
          unless FactoryGirl::Sequence.sequences.key?(sequence)
            raise "No such sequence: #{sequence}"
          end

          FactoryGirl::Sequence.sequences[sequence].next
        end

        def self.alias(pattern, replace)
          Alias.alias(pattern, replace)
        end

        def self.factories
          FactoryGirl::Factory.factories
        end

      end

    end
  end

end

include FactoryGirl::Syntax::Default
